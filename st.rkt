#lang racket

; TODOS
; Add conditional formlet for changing real/ideal

(require web-server/servlet
         web-server/servlet-env
         web-server/templates
         ; net/uri-codec
         racket/runtime-path
         web-server/formlets
         web-server/page
         racket/date
         json)

(require "functions.rkt"
         "model.rkt"
         "crc32.rkt")

(define *app-version* 0.1)
(define *app-date* "September 2015")

; the-chart: The main entries-structure generated by initialize-chart!
(define the-chart (initialize-chart!
                   (build-path (current-directory)
                               "st-chart-data.sqlite")))

;static-files-path: For Javascript and CSS files
;(static-files-path "htdocs")

; app-dispatch: Dispatcher rules for application
(define-values (app-dispatch req)
  (dispatch-rules
   [("") show-index]
   [("") #:method "post" process-edit]
   [("edit") #:method "post" process-edit]
   [("reorder") #:method "post" process-reorder]
   [("c" (string-arg)) show-entry]
   ;; [("register") #:method "post" process-registration]
   ; TODO: Add api dispatcher for JSON
   [else not-found]))

; not-found: request -> response
; 404 page
(define (not-found req)
  (response/full 404 #"Not Found" (current-seconds)
                 TEXT/HTML-MIME-TYPE empty (list #"not found")))

; entry-url: entry -> string
; TODO: Add CRC
(define (entry-url a-entry)
  (string-append "/c/" (entry-crc a-entry)))

; process-edit: request -> response
; Processes edit in DB from POST data
(define (process-edit req)
  ; Store bindings
  (define binds (request-bindings req))
  ; Store CRC in editable field ID
  (define crcid (extract-binding/single 'id binds))
  ; Get Entry from CRC
  (define a-entry (fetch-entry the-chart (hash-ref *ids-hash* crcid)))
  (define p (entry-parent a-entry))
  ; Set response
  (define (done v)
    (response/full
     200 #"Okay"
     (current-seconds)
     TEXT/HTML-MIME-TYPE
     empty
     (list (string->bytes/utf-8 v))))
  
  (cond
    ; Are we changing the title of the self or a child?
    [(exists-binding? 'title binds)
     (let ([v (extract-binding/single 'title binds)]
           [d (if (exists-binding? 'duedate binds)
                  (extract-binding/single 'duedate binds)
                  "")])
       (if (exists-binding? 'duedate binds)
           (entry-edit-entry! a-entry
                              #:title v
                              #:due_date d)
           (entry-set-title! a-entry v))
       (redirect-to (entry-url p)))]
    ; Are we marking an entry as completed?
    [(exists-binding? 'done binds)
     (display "marking item completed")
     (entry-edit-entry! a-entry
                        #:done (extract-binding/single 'done binds))]
    ; Are we adding an entry?
    [(exists-binding? 'add binds)
       (entries-insert-entry! (entry-table a-entry)
                              (extract-binding/single 'add binds)
                              "Ideal"
                              "Real"
                              (get-date)
                              ""
                              (entry-id a-entry)
                              (next-in-order a-entry))
       (let ([e (entries-latest (entry-table a-entry))])
         (hash-set! *ids-hash* (entry-crc e) (entry-id e))
         (redirect-to (entry-url a-entry)))]
    ; Are we deleting an entry?
    [(exists-binding? 'delete binds)
     (entries-delete-entry! a-entry)
     (hash-remove! *ids-hash* crcid)
     (redirect-to (entry-url p))]
    ; Are we changing the ideal?
    [(exists-binding? 'ideal binds)
     (let ([v (extract-binding/single 'ideal binds)])
       (entry-set-ideal! a-entry v)
       (redirect-to (entry-url a-entry)))]
    ; Are we changing the real?
    [(exists-binding? 'real binds)
     (let ([v (extract-binding/single 'real binds)])
       (entry-set-real! a-entry v)
       (redirect-to (entry-url a-entry)))]))

; process-reorder: request -> response
(define (process-reorder req)
  (local
    [; Store hash map of received JSON object
     (define json (bytes->jsexpr (request-post-data/raw req)))
     ; Create pairs of entries and their order from the database
     (define order (reverse (map
                    (lambda (c) (fetch-entry the-chart (hash-ref *ids-hash* c)))
                    (hash-ref json 'order))))]
    ; Print something marginally useful
    ;; (display (map (lambda (e)
    ;;                 (cons (entry-title (car e)) (cdr e))) order))
    ;; (newline)
    ; Iterate through order
    (for/list ([e order]
               [i (range (length order) 0 -1)])
      ; Compare db-order value to array position from JSON
      ; When they are not equal, update the database with the proper value
      (when (or (not (number? (entry-ord e)))
                (not (= (entry-ord e) i)))
        (display (format "~a -> ~a~n" (entry-ord e) i))
        (entry-set-ord! e (number->string i))))
    ; Return an empty response saying things went well
    (response/full 200 #"Okay"
                   (current-seconds)
                   TEXT/HTML-MIME-TYPE
                   empty
                   empty)))

; entry -> string
(define (generate-breadcrumb a-entry)
  (define (get-parents a-entry)
    (cond [(not a-entry) '()]
          [else (cons a-entry (get-parents (entry-parent a-entry)))]))
  (let loop [(parents (reverse (get-parents (entry-parent a-entry))))]
    (cond [(empty? parents) (entry-title a-entry)]
          [else (string-append (link-title (car parents))
                               " / "
                               (loop (cdr parents)))])))

(define (link-title a-entry)
  (let [(title (entry-title a-entry))
        (crc (entry-crc a-entry))]
    (string-append "<a href=\"/c/" crc "\">" title "</a>")))

; entry-template: entry -> template
; Template for rendering an entry
(define (show-template a-entry)
  (include-template "templates/basic.html"))

; show-step: entry -> template
; Template for rendering a step
(define (show-step a-entry)
  (include-template "templates/step.html"))

; show entry: request entry -> response
(define (show-entry req crc)
  (entry-template req (fetch-entry the-chart (hash-ref *ids-hash* crc))))

; index-template: -> response
; Index template, defaults to rendering top-level entry
(define (index-template req)
  (entry-template req (fetch-entry the-chart (entry-id (entries-top the-chart)))))

; entry-template: -> response
; HTTP Response for rendering an entry
(define (entry-template req a-entry)
  (response/full
   200 #"Okay"
   (current-seconds) TEXT/HTML-MIME-TYPE
   empty
   (list (string->bytes/utf-8 (show-template a-entry)))))

; show-index: request -> response
(define (show-index req)
  (index-template req))

; start: request -> response
(define (start request)
  (app-dispatch request))

(define-runtime-path srvpath ".")

; *ids-hash*: Hash map of ids to their crc32'd equivalents
(define (make-ids-hash)
  (make-hash
   (for/list ([e (fetch-all-ids the-chart)])
     (cons (id-crc e) e))))
(define *ids-hash* (make-ids-hash))

(define (start-server)
  (serve/servlet start
                 #:servlet-path ""
                 #:port 8080
                 #:servlet-regexp #rx"^((?!/static/).)*$"
                 #:extra-files-paths (list srvpath)
                 #:launch-browser? #f ; Change when deploying
                 #:stateless? #t))

(start-server)

